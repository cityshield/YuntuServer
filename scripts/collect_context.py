#!/usr/bin/env python3
"""
YuntuServer ‰∏ä‰∏ãÊñáÊèêÂèñËÑöÊú¨
Áî®‰∫éÊèêÂèñÈ°πÁõÆ‰∏≠ÊâÄÊúâÊ®°ÂùóÁöÑÊ†∏ÂøÉ‰∏ä‰∏ãÊñá‰ø°ÊÅØÔºåÂåÖÊã¨Á±ª„ÄÅÂáΩÊï∞„ÄÅAPIÁ´ØÁÇπÁ≠â

Áî®Ê≥ï:
    python scripts/collect_context.py                      # ÊèêÂèñÊâÄÊúâÊ®°Âùó
    python scripts/collect_context.py User Task            # ÊèêÂèñÊåáÂÆöÊ®°Âùó
    python scripts/collect_context.py --json               # ËæìÂá∫ JSON Ê†ºÂºè
    python scripts/collect_context.py --output context.json # ‰øùÂ≠òÂà∞Êñá‰ª∂
"""

import os
import sys
import ast
import json
import argparse
from pathlib import Path
from typing import List, Dict, Any, Optional
from collections import defaultdict


class CodeContextExtractor:
    """‰ª£Á†Å‰∏ä‰∏ãÊñáÊèêÂèñÂô®"""

    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.app_dir = self.project_root / "app"
        self.context = {
            "project": "YuntuServer",
            "models": {},
            "services": {},
            "api_routes": {},
            "schemas": {},
            "utils": {},
            "statistics": {
                "total_models": 0,
                "total_services": 0,
                "total_api_endpoints": 0,
                "total_schemas": 0,
            }
        }

    def extract_all(self, filter_modules: Optional[List[str]] = None):
        """ÊèêÂèñÊâÄÊúâ‰∏ä‰∏ãÊñá"""
        print("üìä ÂºÄÂßãÊèêÂèñÈ°πÁõÆ‰∏ä‰∏ãÊñá...\n", file=sys.stderr)

        self._extract_models(filter_modules)
        self._extract_services(filter_modules)
        self._extract_api_routes(filter_modules)
        self._extract_schemas(filter_modules)

        self._update_statistics()

        print(f"\n‚úÖ ÊèêÂèñÂÆåÊàêÔºÅ", file=sys.stderr)
        print(f"   - Models: {self.context['statistics']['total_models']}", file=sys.stderr)
        print(f"   - Services: {self.context['statistics']['total_services']}", file=sys.stderr)
        print(f"   - API Endpoints: {self.context['statistics']['total_api_endpoints']}", file=sys.stderr)
        print(f"   - Schemas: {self.context['statistics']['total_schemas']}\n", file=sys.stderr)

        return self.context

    def _should_include_module(self, module_name: str, filter_modules: Optional[List[str]]) -> bool:
        """Âà§Êñ≠ÊòØÂê¶Â∫îËØ•ÂåÖÂê´ËØ•Ê®°Âùó"""
        if not filter_modules:
            return True
        return any(f.lower() in module_name.lower() for f in filter_modules)

    def _extract_models(self, filter_modules: Optional[List[str]] = None):
        """ÊèêÂèñ Models"""
        models_dir = self.app_dir / "models"
        if not models_dir.exists():
            return

        print("üîç ÊèêÂèñ Models...", file=sys.stderr)

        for py_file in models_dir.glob("*.py"):
            if py_file.name.startswith("_"):
                continue

            module_name = py_file.stem
            if not self._should_include_module(module_name, filter_modules):
                continue

            model_info = self._parse_model_file(py_file)
            if model_info:
                self.context["models"][module_name] = model_info
                print(f"   ‚úì {module_name}: {len(model_info.get('classes', []))} Á±ª", file=sys.stderr)

    def _extract_services(self, filter_modules: Optional[List[str]] = None):
        """ÊèêÂèñ Services"""
        services_dir = self.app_dir / "services"
        if not services_dir.exists():
            return

        print("üîç ÊèêÂèñ Services...", file=sys.stderr)

        for py_file in services_dir.glob("*.py"):
            if py_file.name.startswith("_"):
                continue

            module_name = py_file.stem
            if not self._should_include_module(module_name, filter_modules):
                continue

            service_info = self._parse_service_file(py_file)
            if service_info:
                self.context["services"][module_name] = service_info
                print(f"   ‚úì {module_name}: {len(service_info.get('classes', []))} Á±ª, {len(service_info.get('functions', []))} ÂáΩÊï∞", file=sys.stderr)

    def _extract_api_routes(self, filter_modules: Optional[List[str]] = None):
        """ÊèêÂèñ API Routes"""
        api_dir = self.app_dir / "api" / "v1"
        if not api_dir.exists():
            return

        print("üîç ÊèêÂèñ API Routes...", file=sys.stderr)

        for py_file in api_dir.glob("*.py"):
            if py_file.name.startswith("_") or py_file.name == "router.py":
                continue

            module_name = py_file.stem
            if not self._should_include_module(module_name, filter_modules):
                continue

            route_info = self._parse_api_file(py_file)
            if route_info:
                self.context["api_routes"][module_name] = route_info
                print(f"   ‚úì {module_name}: {len(route_info.get('endpoints', []))} Á´ØÁÇπ", file=sys.stderr)

    def _extract_schemas(self, filter_modules: Optional[List[str]] = None):
        """ÊèêÂèñ Schemas"""
        schemas_dir = self.app_dir / "schemas"
        if not schemas_dir.exists():
            return

        print("üîç ÊèêÂèñ Schemas...", file=sys.stderr)

        for py_file in schemas_dir.glob("*.py"):
            if py_file.name.startswith("_"):
                continue

            module_name = py_file.stem
            if not self._should_include_module(module_name, filter_modules):
                continue

            schema_info = self._parse_schema_file(py_file)
            if schema_info:
                self.context["schemas"][module_name] = schema_info
                print(f"   ‚úì {module_name}: {len(schema_info.get('classes', []))} Ê®°Âºè", file=sys.stderr)

    def _parse_model_file(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£Êûê Model Êñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)

            info = {
                "file": str(file_path.relative_to(self.project_root)),
                "classes": [],
                "docstring": ast.get_docstring(tree) or ""
            }

            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    class_info = {
                        "name": node.name,
                        "docstring": ast.get_docstring(node) or "",
                        "fields": [],
                        "relationships": [],
                        "methods": []
                    }

                    # ÊèêÂèñÂ≠óÊÆµÂíåÂÖ≥Á≥ª
                    for item in node.body:
                        if isinstance(item, ast.Assign):
                            for target in item.targets:
                                if isinstance(target, ast.Name):
                                    field_name = target.id
                                    field_info = {"name": field_name}

                                    # Â∞ùËØïËé∑ÂèñÂ≠óÊÆµÁ±ªÂûã
                                    if isinstance(item.value, ast.Call):
                                        if hasattr(item.value.func, 'id'):
                                            field_info["type"] = item.value.func.id
                                        elif hasattr(item.value.func, 'attr'):
                                            field_info["type"] = item.value.func.attr

                                    # Âà§Êñ≠ÊòØÂÖ≥Á≥ªËøòÊòØÂ≠óÊÆµ
                                    if field_info.get("type") == "relationship":
                                        class_info["relationships"].append(field_info)
                                    else:
                                        class_info["fields"].append(field_info)

                        elif isinstance(item, ast.FunctionDef):
                            if not item.name.startswith("_"):
                                class_info["methods"].append({
                                    "name": item.name,
                                    "docstring": ast.get_docstring(item) or ""
                                })

                    info["classes"].append(class_info)

            return info
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Ëß£ÊûêÂ§±Ë¥• {file_path.name}: {e}", file=sys.stderr)
            return {}

    def _parse_service_file(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£Êûê Service Êñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)

            info = {
                "file": str(file_path.relative_to(self.project_root)),
                "classes": [],
                "functions": [],
                "docstring": ast.get_docstring(tree) or ""
            }

            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    class_info = {
                        "name": node.name,
                        "docstring": ast.get_docstring(node) or "",
                        "methods": []
                    }

                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            method_info = {
                                "name": item.name,
                                "docstring": ast.get_docstring(item) or "",
                                "is_async": isinstance(item, ast.AsyncFunctionDef),
                                "parameters": [arg.arg for arg in item.args.args]
                            }
                            class_info["methods"].append(method_info)

                    info["classes"].append(class_info)

                elif isinstance(node, ast.FunctionDef) and node.col_offset == 0:
                    # È°∂Â±ÇÂáΩÊï∞
                    func_info = {
                        "name": node.name,
                        "docstring": ast.get_docstring(node) or "",
                        "is_async": isinstance(node, ast.AsyncFunctionDef),
                        "parameters": [arg.arg for arg in node.args.args]
                    }
                    info["functions"].append(func_info)

            return info
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Ëß£ÊûêÂ§±Ë¥• {file_path.name}: {e}", file=sys.stderr)
            return {}

    def _parse_api_file(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£Êûê API Êñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)

            info = {
                "file": str(file_path.relative_to(self.project_root)),
                "endpoints": [],
                "docstring": ast.get_docstring(tree) or ""
            }

            # Êü•Êâæ router ÂâçÁºÄ
            router_prefix = ""
            for node in ast.walk(tree):
                if isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name) and target.id == "router":
                            if isinstance(node.value, ast.Call):
                                for keyword in node.value.keywords:
                                    if keyword.arg == "prefix":
                                        if isinstance(keyword.value, ast.Constant):
                                            router_prefix = keyword.value.value

            # ÊèêÂèñÁ´ØÁÇπ
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    # Ê£ÄÊü•Ë£ÖÈ•∞Âô®
                    for decorator in node.decorator_list:
                        if isinstance(decorator, ast.Attribute):
                            if decorator.attr in ['get', 'post', 'put', 'delete', 'patch']:
                                endpoint_info = {
                                    "method": decorator.attr.upper(),
                                    "function": node.name,
                                    "docstring": ast.get_docstring(node) or "",
                                    "is_async": isinstance(node, ast.AsyncFunctionDef),
                                    "parameters": [arg.arg for arg in node.args.args]
                                }

                                # Â∞ùËØïËé∑ÂèñË∑ØÂæÑ
                                if isinstance(decorator, ast.Attribute) and hasattr(decorator.value, 'id'):
                                    if decorator.value.id == 'router':
                                        # Êü•ÊâæÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞‰Ωú‰∏∫Ë∑ØÂæÑ
                                        parent = None
                                        for p_node in ast.walk(tree):
                                            for child in ast.iter_child_nodes(p_node):
                                                if child == decorator:
                                                    parent = p_node
                                                    break

                                        # ÁÆÄÂåñÂ§ÑÁêÜÔºö‰ªéÂáΩÊï∞ÂêçÊé®Êñ≠
                                        endpoint_info["path"] = router_prefix + "/" + node.name.replace("_", "-")

                                info["endpoints"].append(endpoint_info)

            return info
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Ëß£ÊûêÂ§±Ë¥• {file_path.name}: {e}", file=sys.stderr)
            return {}

    def _parse_schema_file(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£Êûê Schema Êñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)

            info = {
                "file": str(file_path.relative_to(self.project_root)),
                "classes": [],
                "docstring": ast.get_docstring(tree) or ""
            }

            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    class_info = {
                        "name": node.name,
                        "docstring": ast.get_docstring(node) or "",
                        "fields": []
                    }

                    # ÊèêÂèñÂ≠óÊÆµÔºàÂ∏¶Á±ªÂûãÊ≥®Ëß£Ôºâ
                    for item in node.body:
                        if isinstance(item, ast.AnnAssign):
                            if isinstance(item.target, ast.Name):
                                field_info = {
                                    "name": item.target.id,
                                    "type": ast.unparse(item.annotation) if hasattr(ast, 'unparse') else ""
                                }
                                class_info["fields"].append(field_info)

                    info["classes"].append(class_info)

            return info
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Ëß£ÊûêÂ§±Ë¥• {file_path.name}: {e}", file=sys.stderr)
            return {}

    def _update_statistics(self):
        """Êõ¥Êñ∞ÁªüËÆ°‰ø°ÊÅØ"""
        self.context["statistics"]["total_models"] = sum(
            len(m.get("classes", [])) for m in self.context["models"].values()
        )
        self.context["statistics"]["total_services"] = sum(
            len(s.get("classes", [])) for s in self.context["services"].values()
        )
        self.context["statistics"]["total_api_endpoints"] = sum(
            len(a.get("endpoints", [])) for a in self.context["api_routes"].values()
        )
        self.context["statistics"]["total_schemas"] = sum(
            len(s.get("classes", [])) for s in self.context["schemas"].values()
        )


def main():
    parser = argparse.ArgumentParser(
        description="ÊèêÂèñ YuntuServer È°πÁõÆÁöÑ‰ª£Á†Å‰∏ä‰∏ãÊñá",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Á§∫‰æãÁî®Ê≥ï:
  python scripts/collect_context.py                      # ÊèêÂèñÊâÄÊúâÊ®°Âùó
  python scripts/collect_context.py User Task            # ‰ªÖÊèêÂèñ User Âíå Task Áõ∏ÂÖ≥Ê®°Âùó
  python scripts/collect_context.py --json               # ËæìÂá∫ JSON Ê†ºÂºè
  python scripts/collect_context.py -o context.json      # ‰øùÂ≠òÂà∞Êñá‰ª∂
  python scripts/collect_context.py User --pretty        # ÁæéÂåñËæìÂá∫
        """
    )

    parser.add_argument(
        "modules",
        nargs="*",
        help="Ë¶ÅÊèêÂèñÁöÑÊ®°ÂùóÂêçÁß∞ÔºàÂèØÈÄâÔºå‰∏çÊåáÂÆöÂàôÊèêÂèñÊâÄÊúâÔºâ"
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="ËæìÂá∫ JSON Ê†ºÂºèÔºàÈªòËÆ§Ôºâ"
    )
    parser.add_argument(
        "-o", "--output",
        type=str,
        help="‰øùÂ≠òÂà∞ÊåáÂÆöÊñá‰ª∂"
    )
    parser.add_argument(
        "--pretty",
        action="store_true",
        help="ÁæéÂåñ JSON ËæìÂá∫"
    )

    args = parser.parse_args()

    # Ëé∑ÂèñÈ°πÁõÆÊ†πÁõÆÂΩï
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # ÊèêÂèñ‰∏ä‰∏ãÊñá
    extractor = CodeContextExtractor(str(project_root))
    context = extractor.extract_all(filter_modules=args.modules if args.modules else None)

    # ËæìÂá∫ÁªìÊûú
    indent = 2 if args.pretty else None
    json_output = json.dumps(context, ensure_ascii=False, indent=indent)

    if args.output:
        output_path = Path(args.output)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(json_output)
        print(f"‚úÖ Â∑≤‰øùÂ≠òÂà∞: {output_path}", file=sys.stderr)
    else:
        print(json_output)


if __name__ == "__main__":
    main()
